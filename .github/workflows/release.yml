name: Build and Release
concurrency:
  group: ${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches:
      - main  # Triggers on push to main branch
    # The job will only run if the commit message contains the keyword '[run-ci]'
  workflow_dispatch:  # Allows manual trigger from GitHub Actions tab

env:
  CARGO_TERM_COLOR: always
  RUSTC_WRAPPER: sccache
  SCCACHE_DIR: C:\Users\runneradmin\.cache\sccache
  SCCACHE_IDLE_TIMEOUT: 0

jobs:
  build-and-release:
    if: >-
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'push' && contains(github.event.head_commit.message, '[run-ci]'))
    runs-on: windows-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}
          submodules: recursive

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: x86_64-pc-windows-msvc

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Cache Node.js modules
        uses: actions/cache@v4
        with:
          path: repak-gui/node_modules
          key: ${{ runner.os }}-node-${{ hashFiles('repak-gui/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-

      - name: Install Frontend Dependencies
        working-directory: repak-gui
        run: npm install

      - name: Cache Cargo Registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-registry-

      - name: Cache Rust Build (target folder)
        uses: actions/cache@v4
        with:
          path: target/
          key: ${{ runner.os }}-cargo-target-${{ hashFiles('**/Cargo.lock', 'Cargo.toml', 'repak-gui/tauri.conf.json', 'repak-gui/package.json') }}-${{ hashFiles('**/*.rs') }}
          restore-keys: |
            ${{ runner.os }}-cargo-target-${{ hashFiles('**/Cargo.lock', 'Cargo.toml', 'repak-gui/tauri.conf.json', 'repak-gui/package.json') }}-
            ${{ runner.os }}-cargo-target-

      - name: Install sccache
        uses: mozilla-actions/sccache-action@v0.0.4

      - name: Cache sccache
        uses: actions/cache@v4
        with:
          path: C:\Users\runneradmin\.cache\sccache
          key: ${{ runner.os }}-sccache-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-sccache-

      - name: Start sccache server
        shell: pwsh
        run: |
          sccache --start-server
          sccache --show-stats

      - name: Auto-Increment Version (Local)
        id: version
        shell: pwsh
        run: |
          # Read current version from Cargo.toml
          $cargoContent = Get-Content -Path "Cargo.toml" -Raw
          $currentVersion = [regex]::Match($cargoContent, '(?m)^version\s*=\s*"([^"]+)"').Groups[1].Value
          
          Write-Host "Current version: $currentVersion" -ForegroundColor Yellow
          
          # Parse version (MAJOR.MINOR.PATCH)
          $versionParts = $currentVersion -split '\.'
          $major = [int]$versionParts[0]
          $minor = [int]$versionParts[1]
          $patch = [int]$versionParts[2]
          
          # Increment patch version
          $patch++
          $newVersion = "$major.$minor.$patch"
          
          Write-Host "New version: $newVersion" -ForegroundColor Green
          
          # Update Cargo.toml
          $cargoContent = $cargoContent -replace '(?m)^version\s*=\s*"[^"]+"', "version = `"$newVersion`""
          Set-Content -Path "Cargo.toml" -Value $cargoContent -NoNewline
          
          # Update tauri.conf.json
          $tauriPath = "repak-gui\tauri.conf.json"
          $tauriContent = Get-Content -Path $tauriPath -Raw
          $tauriContent = $tauriContent -replace '"version":\s*"[^"]+"', "`"version`": `"$newVersion`""
          Set-Content -Path $tauriPath -Value $tauriContent -NoNewline
          
          # Update package.json
          $packagePath = "repak-gui\package.json"
          $packageContent = Get-Content -Path $packagePath -Raw
          $packageContent = $packageContent -replace '"version":\s*"[^"]+"', "`"version`": `"$newVersion`""
          Set-Content -Path $packagePath -Value $packageContent -NoNewline
          
          # Set outputs
          echo "VERSION=$newVersion" >> $env:GITHUB_OUTPUT
          echo "OLD_VERSION=$currentVersion" >> $env:GITHUB_OUTPUT

      - name: Create Distribution Package (ZIP Only)
        id: package
        shell: pwsh
        run: |
          Write-Host "Creating ZIP distribution package..." -ForegroundColor Cyan
          .\build_and_package.ps1 -Configuration release -Zip
          
          $version = "${{ steps.version.outputs.VERSION }}"
          $zipPath = "dist\Repak-Gui-Revamped-v$version.zip"
          
          if (Test-Path $zipPath) {
            $zipSize = [math]::Round((Get-Item $zipPath).Length / 1MB, 2)
            Write-Host "ZIP created: $zipSize MB" -ForegroundColor Green
            echo "ZIP_PATH=$zipPath" >> $env:GITHUB_OUTPUT
            echo "ZIP_SIZE=$zipSize" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "ERROR: ZIP file not found!" -ForegroundColor Red
            exit 1
          }

      - name: Commit and Push Version Bump
        shell: pwsh
        run: |
          $newVersion = "${{ steps.version.outputs.VERSION }}"
          
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          # Commit version bump
          git add Cargo.toml repak-gui/tauri.conf.json repak-gui/package.json
          git commit -m "chore: bump version to $newVersion [skip ci]"
          
          # Create and push tag
          git tag "v$newVersion"
          git push origin HEAD:main
          git push origin "v$newVersion"

      - name: Upload ZIP to Cloudflare R2
        id: r2_upload
        shell: pwsh
        env:
          R2_ACCESS_KEY_ID: ${{ secrets.R2_ACCESS_KEY_ID }}
          R2_SECRET_ACCESS_KEY: ${{ secrets.R2_SECRET_ACCESS_KEY }}
          R2_ENDPOINT: ${{ secrets.R2_ENDPOINT }}
          R2_BUCKET: ${{ secrets.R2_BUCKET_NAME }}
          R2_PUBLIC_URL: ${{ secrets.R2_PUBLIC_URL }}
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $zipPath = "${{ steps.package.outputs.ZIP_PATH }}"
          $fileName = "Repak-Gui-Revamped-v$version.zip"
          
          Write-Host "Uploading to Cloudflare R2..." -ForegroundColor Cyan
          Write-Host "  Bucket: $env:R2_BUCKET" -ForegroundColor Yellow
          Write-Host "  File: $fileName" -ForegroundColor Yellow
          
          # Install AWS CLI if not present (R2 uses S3-compatible API)
          if (-not (Get-Command aws -ErrorAction SilentlyContinue)) {
            Write-Host "Installing AWS CLI..." -ForegroundColor Yellow
            choco install awscli -y
            refreshenv
          }
          
          # Configure AWS CLI for R2
          $env:AWS_ACCESS_KEY_ID = $env:R2_ACCESS_KEY_ID
          $env:AWS_SECRET_ACCESS_KEY = $env:R2_SECRET_ACCESS_KEY
          
          # Upload to R2
          aws s3 cp $zipPath "s3://$env:R2_BUCKET/$fileName" --endpoint-url $env:R2_ENDPOINT
          
          if ($LASTEXITCODE -eq 0) {
            # Construct public URL
            $downloadUrl = "$env:R2_PUBLIC_URL/$fileName"
            
            Write-Host "‚úÖ Upload successful!" -ForegroundColor Green
            Write-Host "Download URL: $downloadUrl" -ForegroundColor Cyan
            
            echo "DOWNLOAD_URL=$downloadUrl" >> $env:GITHUB_OUTPUT
            echo "FILE_NAME=$fileName" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "‚ùå R2 upload failed!" -ForegroundColor Red
            exit 1
          }

      - name: Create GitHub Release (Private)
        id: create_release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ steps.version.outputs.VERSION }}
          name: Repak GUI Revamped v${{ steps.version.outputs.VERSION }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: ${{ steps.package.outputs.ZIP_PATH }}
          body: |
            ## Repak GUI Revamped v${{ steps.version.outputs.VERSION }}
            
            **Public Download Link:** ${{ steps.r2_upload.outputs.DOWNLOAD_URL }}
            
            This release was automatically generated.
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Post Release to Discord
        if: success()
        shell: pwsh
        env:
          DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_URL }}
        run: |
          $version = "${{ steps.version.outputs.VERSION }}"
          $oldVersion = "${{ steps.version.outputs.OLD_VERSION }}"
          $zipSize = "${{ steps.package.outputs.ZIP_SIZE }}"
          $downloadUrl = "${{ steps.r2_upload.outputs.DOWNLOAD_URL }}"
          
          if (-not $env:DISCORD_WEBHOOK) {
            Write-Host "Discord webhook not configured, skipping notification" -ForegroundColor Yellow
            exit 0
          }
          
          Write-Host "Posting release to Discord..." -ForegroundColor Cyan
          Write-Host "Download URL: $downloadUrl" -ForegroundColor Yellow
          
          # Create Discord embed
          $payload = @{
            content = "<@&1448687070296936600>"
            embeds = @(
              @{
                title = "üöÄ New Release: Repak X v$version"
                description = "A new version has been released!`n`n**What's New:**`n‚Ä¢ Version bumped from $oldVersion ‚Üí $version`n‚Ä¢ Fresh build with latest changes"
                color = 9109504 # Dark Red color
                fields = @(
                  @{
                    name = "üì¶ Package"
                    value = "``Repak-Gui-Revamped-v$version.zip``"
                    inline = $true
                  }
                  @{
                    name = "üìä Size"
                    value = "$zipSize MB"
                    inline = $true
                  }
                  @{
                    name = "‚¨áÔ∏è Download"
                    value = "**[Click here to download]($downloadUrl)**"
                    inline = $false
                  }
                )
                timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
                footer = @{
                  text = "Repak X ‚Ä¢ Auto-Release"
                }
              }
            )
          } | ConvertTo-Json -Depth 10
          
          # Send to Discord
          try {
            Invoke-RestMethod -Uri $env:DISCORD_WEBHOOK -Method Post -Body $payload -ContentType 'application/json'
            Write-Host "‚úÖ Release posted to Discord successfully!" -ForegroundColor Green
          } catch {
            Write-Host "‚ùå Failed to post to Discord: $_" -ForegroundColor Red
            Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
          }

      - name: Upload Build Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: repak-gui-revamped-v${{ steps.version.outputs.VERSION }}
          path: ${{ steps.package.outputs.ZIP_PATH }}
          retention-days: 30

      - name: Stop sccache and show stats
        if: always()
        shell: pwsh
        run: |
          sccache --show-stats 2>$null
          sccache --stop-server 2>$null
          exit 0
